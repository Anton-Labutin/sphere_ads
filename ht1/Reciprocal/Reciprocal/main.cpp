//
//  main.cpp
//  Reciprocal
//
//  Created by Лабутин Антон Александрович on 13.03.2021.
/*
 Обратное число по модулю

 Известно, что команда деления целых чисел на современных компьютерах исполняется неприлично долго. Оптимизирующие компиляторы во многих случаях заменяют операцию деления на константу группой операций, в которых имеется умножение на другую константу.
 Для этого компилятору, в числе других действий, требуется найти такое неотрицательное число q для заданного делителя p, что q * p = 1 по известному модулю m.
 Ваша задача по заданным числам 2 ⩽ p,m ⩽ 4 294 967 295 найти любое неотрицательное число q такое, чтобы (p * q) (mod m) = 1.
 Известно также, что m — простое число, и что для заданных p и m ответ существует.

 Формат входных данных
 p m

 Формат результата
 q

 Примеры

 Входные данные
 5 7
 Результат работы
 3

 Входные данные
 199212331 4010101141
 Результат работы
 525555399

 */
//

#include <cstdio>

using ULL = unsigned long long;
using LL = long long;

ULL
extendedGCD(ULL p, ULL m)
{
    LL x1 = 0, x2 = 1;
    LL y1 = 1, y2 = 0;

    ULL a = (p >= m ? p : m);
    ULL b = (p < m ? p : m);

    while (b > 0) {
        ULL q = a / b;
        ULL r = a - q * b;
        LL x = x2 - q * x1;
        LL y = y2 - q * y1;

        a = b;
        b = r;
        x2 = x1;
        x1 = x;
        y2 = y1;
        y1 = y;
    }

    return (y2 > 0 ? y2 : y2 + m);
}

int
main()
{
    ULL p, m;
    scanf("%llu%llu", &p, &m);

    ULL q = extendedGCD(p, m);

    printf("%llu\n", q);

    return 0;
}
