//
//  main.cpp
//  Cakes
//
//  Created by Лабутин Антон Александрович on 30.03.2021.
//

/*
 Разрезание блинов

 На очень большом столе разложено много абсолютно круглых блинов, некоторые из которых могут частично или полностью налегать друг на друга. Абсолютно прямым ножом проводится луч из первой точки по направлению ко второй. Требуется определить, какие из блинов будут задеты разрезом. Касания НЕ учитываются.

 Input format
 В первой строке — координаты двух точек на плоскости, которые определяют луч разреза.
 Во второй строке — количество блинов 1⩽N⩽100000.
 В следующих N строках по три числа — координаты центра блина и его радиус.
 Все координаты — целые числа от -10000 до 10000.
 Радиус — строго положительное целое число.

 Output format
 Номера разрезанных блинов в порядке возрастания. Нумерация блинов начинается с 1.

 Examples
 Input
 0 0 0 1
 5
 -1 -1 1
 -2 -2 1
 -3 -3 4
 1 2 4
 3 1 1

 Output
 4

 Input
 0 0 0 1
 2
 3 0 3
 3 0 1

 Output

 */

#include <cstdio>
#include <cmath>

int
main()
{
    int x0, y0;
    scanf("%d%d", &x0, &y0);

    int x1, y1;
    scanf("%d%d", &x1, &y1);

    double A = y0 - y1;
    double B = x1 - x0;
    double temp = A * A + B * B;

    unsigned N;
    scanf("%u", &N);

    int xc, yc;
    double r;

    for (unsigned currCircle = 0; currCircle < N; ++currCircle) {
        scanf("%d%d", &xc, &yc);
        scanf("%lf", &r);

		// сместим центр окружности в начало координат
        double x0c = x0 - xc;
        double x1c = x1 - xc;
        double y0c = y0 - yc;
        double y1c = y1 - yc;

        double C = x0c * y1c - x1c * y0c;
        // расстояние от центра окружности до её проекции на прямую, содержащую луч
        double dist = abs(C) / sqrt(temp);

		// проекция центра окружности на прямую
        double xt = -(A * C) / temp;
        double yt = -(B * C) / temp;

        // скалярное произведение: если > 0, то проекция лежит на луче
        double scalProd = (x1c - x0c) * (xt - x0c) + (y1c - y0c) * (yt - y0c);

		// проекция может не лежать на луче и быть внутри круга
        double dist2 = sqrt(x0c * x0c + y0c * y0c);
        if (dist < r && (scalProd >= 0 || dist2 < r)) {
            printf("%u ", currCircle + 1);
        }

    }

    return 0;
}
